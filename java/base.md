# Java 语言基础

## 基础语法

### 数据类型

- 基本数据类型
  - 数值类型
    - 整数类型：byte, short, int, long
    - 浮点类型：float, double
  - 字符类型：char
  - 布尔类型：boolean
- 引用类型
  - 类 class
  - 接口 interface
  - 数据 []

#### Java基本数据类型宽度

![java基本数据类型](img/java_base_type.png)

#### 典型问题

- 用最高效的方法计算 2 * 8

  2 << 3 (左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方)

- Math.round(11.5)等于多少？Math.round(-11.5)等于多少？

  Math.round(11.5) = 12 , Math.round(-11.5) = -11. 四舍五入的原理是在参数上 +0.5 然后向下取整

- float f = 3.4 是否正确？
  
  不正确。3.4 是双精度数，将双精度(double)赋值给浮点数(float)属于下转型(down-casting)会造成精度损失，因此需要强制类型转换 float f = (float) 3.4 或者 float f = 3.4F

- short s = 1; s = s + 1; 有错吗？ short s = 1; s += 1; 有错吗？
  
  short s = 1; s = s + 1;由于 1 是 int 型， 因此运算 s + 1 也是 int 型，需要强制类型转换才能将 int 赋值给 short
  short s = 1; s += 1;可以正确编译，s += 1 相当于 s = (short)(s + 1),隐含了强制类型转换

#### 关键字

- final 作用
  
  用于修饰类、属性和方法

  - 被final修饰的类不可以被继承
  - 被final修饰的方法不可以被重写
  - 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的

- final, finally, finalize 区别

  - final可以修饰类、变量、方法，修饰类表示类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值
  - finally一般作用在try-catch代码块，在处理异常时，通常将一定要执行的代码块放到finally代码块中，表示不管是否出现异常，该代码都会执行，一般用来放一些关闭资源的代码
  - finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用 System.gc() 方法时，由垃圾回收器调用 finalize()，回收垃圾，一个对象是否可以回收的最后判断

- this 关键字的用法
  
  this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。this用法在 java 中大体分为3种：
  1. 普通的直接引用，this相当于当前对象本身
  2. 形参与成员变量重名，用this来区分

    ```java
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    ```

  3. 引用本类的构造函数

    ```java
    class Person{
        private String name;
        private int age;
        public Person() {
        }
        public Person(String name) {
            this.name = name;
        }
        public Person(String name, int age) {
            this(name);
            this.age = age;
        }
    }
    ```

- super 关键字用法
  
  super可以理解为指向自己父类对象的一个指针，而且这个父类是离自己最近的一个父类, super 三种用法:

  1. 普通的直接引用，与this类似，super相当于指向当前对象的父类的引用，这样就可以用 super.xxx来引用父类的成员
  2. 子类的成员变量或者方法与父类中的成员变量或方法同名时，用super来区分
  3. 引用父类构造函数；super(...params)应该为构造函数的第一语句；this(...params)同理也应该为构造函数的第一条语句

- this 和 super 的区别

  - super 引用当前对象的直接父类
  - this 引用当前对象
  - super() 在子类中调用父类的构造方法， this() 在当前类调用当前类的构造方法
  - super() 和 this()  都需要放在构造方法内第一行
  - 可以用this调用一个构造器，却不能调用两个
  - this() 和 super() 不能同时出现在一个构造函数里，因为 this() 必然会调用其他构造函数，其他的构造函数必然也会有 super() 语句存在，所以在同一个构造函数里有相同的语句，编译器不会通过
  - this() 和 super() 都是指的对象， 所以，都不能在 static 环境中使用。包括：static变量、static方法、static 语句块
  - 从本质上讲，this 是一个指向本对象的指针， 然而 super 是一个 Java 关键字

- static 关键字
  
  static 的主要意义在于创建独立于具体对象的域变量或者方法。以致于及时没有创建对象，也能使用属性和调用方法；static 还有一个比较关键的作用是 **用来形成静态代码块以优化程序性能**。 static 块可以置于类中的任何地方，类可以有多个 static 块。在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。由于 static 块的这种特性，所以说 static 块能够优化程序性能。因此在很时候会将一些只需要进行一次的初始化操作放到 static 代码块中进行。

- staic 独特之处
  
  1. 被 static 修饰的变量或者方法独立于该类的任何对象。也就是说这些变量和方法 **不属于任何一个实例对象，而是被类的实例所共享**
  2. 在该类被第一次加载的时候，就会去加载被 static 修饰的部分，而且只会在类第一次使用时加载并进行初始化。注意这只是在第一次使用时初始化，后面根据需要是可以再次赋值的。
  3. static 变量挂在类加载的时候分配空间，以后在创建类的对象时不会重新分配。可以任意赋值
  4. 被static 修饰的变量或者方法优先于对象存在，也就是说在类被加载完毕之后，及时没有创建对象也可以访问

- static 应用场景

  static 注意事项：静态只能访问静态；非静态可以访问非静态和静态

  1. 修饰成员变量
  2. 修饰成员方法
  3. 静态代码块
  4. 修饰类（修饰类的内部内，也就是静态内部类）
  5. 静态导包 ？

## 面向对象

**封装、继承、多态**

- 封装：隐藏对象的属性和实现细节，今对外提供公共的访问方式，将变化隔离，便于使用，提高复用性和安全性
- 继承：在已存在的类定义的基础上建立新类的技术，新类可以增加新的数据或者新的功能，也可以使用父类的功能，但不能选择性的继承父类。可以通过继承提高代码的复用性。继承是多态的前提
- 多态：父类或者接口定义的引用变量可以指向子类或者具体实现类的实例对象。提高了程序的扩展性

  在 Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中的同一方法）。方法重载(overload)实现的是编译时的多态性（也称为前绑定）；方法重写(override)实现的是运行时的多态性（也称为后绑定）。

  一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：

    - 方法重写（子类继承父类并重写父类中已有的或抽象的方法）
    - 对象造型（用父类型引用子类行对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）

### 什么是多态机制？Java语言是如何实现多态的？

  所谓多态是指程序中定义的引用比变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。即一个引用变量到底指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能决定。因此在程序运行时才能确定具体的类，这样不用修改程序源代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变。即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是 **多态**
  
  **多态**分为 **运行时多态** 和 **编译时多态**。编译时多态是静态的，主要指方法重载，它是根据参数列表不同来区别不同的函数，通过编译之后成为不同的函数，在运行时算不上多态；运行时多态是动态的，它是通过动态绑定来实现的，也就是我们常说的多态

#### 多态的实现

  Java 实现多态有三个必要条件：继承、重写、向上转型
  
  - 继承： 多态中必须存在有继承关系的子类和父类
  - 重写：子类对父类的某些方法进行重新定义，在调用这些方法是会调用子类方法
  - 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备能力调用父类和子类的方法
  
  在Java语言中，实现多态遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，而不是由引用变量的类型来决定。但是这个被调用的方法必须在超类中定义过，也就是被子类覆盖的方法

#### 面向对象的五大基本原则

- 单一职责原则（single responsibility principle）: 类的功能单一
- 开闭原则（open-close principle）: 对扩展开放，对修改封闭
- 里氏替换原则（the Liskov substitution principle）: 子类可以替换父类出现在父类能够出现的地方
- 依赖倒置原则（the dependency inversion princple）: 具体实现依赖与抽象，而抽象不能依赖于具体实现；高层次模块和低层次模块都应该依赖于抽象
- 接口分离原则(the interface segregation princple) : 设计时多采用与特定的客户类相关的接口比采用一个通用的接口好

### 类和接口

#### 抽象类和接口对比

  抽象类是用于捕捉子类的通用特性；接口是抽象方法的集合。从设计层面来讲，抽象类是对类的抽象，是一种模版设计；接口是行为抽象，是一种行为规范

- 相同点
  
  - 接口和抽象类都不能实例化
  - 都位于继承的顶端，用于被实现或继承
  - 都包含抽方法，其子类都必须覆写这些抽象方法

- 不同点

参数 | 抽象类 | 接口
----- | ----- | -----
声明 | 抽象类使用abstract关键字声明 | 接口使用interface关键字声明
实现 | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现
构造器 | 抽象类可以有构造器 | 接口不能有构造器
访问修饰符 | 抽象类中的方法可以是任意访问修饰符 | 接口方法默认修饰符是public。并且不允许定义为 private 或者 protected
多继承 | 一个类最多只能继承一个抽象类 | 一个类可以实现多个接口
字段声明 | 抽象类的字段声明可以是任意的 | 接口的字段默认都是 static 和 final 的

**备注**: Java8 中接口中引入了默认方法和静态方法，以减少抽象类和接口之间的差异。在Java8中可以为接口提供默认实现的方法，而不用强制子类来实现它。

接口和抽象类各有取舍，在接口和抽象类的选择上，必须遵守这样一个原则：

- 行为模型应该总是通过接口来定义，优先选用接口，尽量少用抽象类
- 需要定义子类的行为，又要为子类提供通用的功能时，优先选择抽象类

#### 抽象类和普通类

- 普通类不能包含抽象方法，抽象类可以包含抽象方法
- 抽象类不能实例化，普通类可以直接实例化
- 抽象类不能用 final 修饰。抽象类就是让其他类继承的，与 final 约束矛盾
  
#### 对象实例和对象引用

- new 关键字创建对象实例，对象实例在堆内存中；对象引用指向对象实例，对象引用在栈内存中
- 一个对象引用可以指向0个或者1个对象；一个对象可以有n个引用指向它

#### 变量与方法

- 成员变量与局部变量

  - 成员变量针对整个类有效；局部变量一般在方法和语句块有效
  - 成员变量随对象创建而存在，对象销毁而小时，存储在 **堆内存**；局部变量在方法被调用或者语句被执行是存在，方法调用完成和语句执行完成就自动释放，存储在 **栈内存**
  - 在使用变量是遵循 **就近原则**，首先在局部范围找，然后在成员范围找

- Java中定义一个不做事且没有参数的构造方法的作用
  
  Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类的特定构造方法，则会调用父类 **没有参数的构造函数方法**。因此，如果父类只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可执行。解决办法是在父类加一个不做事且没有参数的构造函数

  在调用子类构造方法之前会调用父类没有参数的构造方法，其目的是帮助子类做初始化

  构造方法的主要作用是完成类对象的初始化工作；即使一个类没有声明构造方法，也可以实例化，因为会有默认的不带参数的构造方法

  构造方法与类名相同；没有返回值，但不能用void声明构造函数；生成类的对象时自动执行，无需调用

- 静态变量、实例变量

  - **静态变量**: 不属于任何对象，只属于类，在内存中只有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间
  - **实例变量**: 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量属于实例对象。在内存中创建几次对象就会有几份实例变量

- 静态方法、实例方法

  - 在外部调用静态方法，可以使用 **类名.方法名** 或者 **对象名.方法名**；而实例方法只能通过后者
  - 静态方法在访问本类的成员时，只允许访问静态成员（静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制

#### 内部类

Java中可以讲一个类定义在另外一个类的内部，就是 **内部类**。内部类本身就是类的一个属性，与其他属性定义方式一致

内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类

- 静态内部类
  
  ```java
    public class Outer {

        private static int radius = 1;

        static class StaticInner {
            public void visit() {
                System.out.println("visit outer static  variable:" + radius);
            }
        }
    }
  ```

  静态内部类可以访问外部类所有的静态变量，而不可以访问外部类的非静态变量；静态内部类的创建方式：`new OuterClass.InnerClass()`

- 成员内部类
  
  ```java
    public class Outer {

        private static  int radius = 1;
        private int count =2;
        
        class Inner {
            public void visit() {
                System.out.println("visit outer static  variable:" + radius);
                System.out.println("visit outer   variable:" + count);
            }
        }
    }
  ```

  成员内部类可以访问外部类的所有变量和方法，包括静态和非静态，私有和公有；成员内部类依赖于外部类的实例，创建方式： `OuterClassObj.new InnerClass()`

  ```java
    Outer outer = new Outer();
    Outer.Inner inner = outer.new Inner();
    inner.visit();
  ```

- 局部内部类
  
  定义在方法中的内部类

  ```java
    public class Outer {

        private  int out_a = 1;
        private static int STATIC_b = 2;

        public void testFunctionClass(){
            int inner_c =3;
            class Inner {
                private void fun(){
                    System.out.println(out_a);
                    System.out.println(STATIC_b);
                    System.out.println(inner_c);
                }
            }
            Inner  inner = new Inner();
            inner.fun();
        }
        public static void testStaticFunctionClass(){
            int d =3;
            class Inner {
                private void fun(){
                    // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量
                    System.out.println(STATIC_b);
                    System.out.println(d);
                }
            }
            Inner  inner = new Inner();
            inner.fun();
        }
    }
  ```

  定义在实例方法重的局部类可以访问外部类的所有变量和方法，定义在静态方法重的局部类只能访问外部类的静态变量和方法。局部内部类对象创建：`new InnerClass()`

  ```java
    public static void testStaticFuncClass() {
        class Inner {
        }
        Inner inner = new Inner();
    }
  ```

- 匿名内部类

  匿名内部类就是没有名字的内部类，日常开发中经常使用

  ```java
    public class Outer {
        private void test(final int i) {
            new Service() {
                public void method() {
                    for (int j = 0; j < i; j ++) {
                        System.out.println("匿名内部类");
                    }
                }
            }.method();
        }
    }

    // 匿名内部类必须继承或者实现一个已有的接口
    interface Service {
        void method();
    }
  ```

  除了没有名字，匿名类还有一下特点：

  - 匿名内部类必须继承一个抽象类或者实现一个接口
  - 匿名内部类不能定义任何静态成员和静态方法
  - 当所在的方法的形参需要被匿名内部类使用时，必须声明为 `final`
  - 匿名内部类不能是抽象的，它必须实现继承的类或者实现的接口的所有抽象方法

  匿名内部类创建方式

  ```java
    new class/interface {
        // 匿名内部类实现部分
    }
  ```

- 内部类的优点
  
  - 一个内部类对象可以访问创建它的外部类的对象的内容，包括私有数据
  - 内部类不为同一包的其他类可见，具有很好的封装性
  - 内部类有效实现了 “多重继承”，优化Java单继承缺陷
  - 匿名内部类可以方便的定义回调

- 内部类的应用场景
  
  - 一些多算法场合
  - 解决一些非面向对象的语句块
  - 适当使用内部类，是代码更加灵活和富有扩扩展性
  - 当某个类除了它的外部类，不再被其他类使用时

- 局部内部类和匿名内部类访问局部变量时，为什么变量必须加上 `final` ?
  
  ```java
    public class Outer {
        void outMethod () {
            final int a = 10;
            class Inner {
                void innerMethod() {
                    System.out.println(a);
                }
            }
        }
    }
  ```

  **生命周期不一致**，局部变量直接存储在栈中，当方法执行结束，非 final 的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加上 final，就可以确保局部内部类使用的变量和外层的局部变量分开。

### 重写、重载

- 构造器不能被继承，因此不能被重写，但可以被重载
- 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态，后者实现的是运行时的多态
- **重载**： 发生在同一个类中，方法名相同，参数列表不同（参数类型不同，个数不同，顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分
- **重写**：发生在父类的子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问的修饰符大于等于父类（里氏替换原则）；如果父类的方法修饰符是 `private` 则子类中不能重写

### 对象相等
